const t=window.MnApp.h;class e{componentWillLoad(){console.log("componentWillLoad()"),console.log(this.nameProp),console.log(this.nameState)}componentDidLoad(){console.log("componentDidLoad()"),console.log(this.nameProp),console.log(this.nameState)}componentWillUpdate(){console.log("componentWillUpdate()"),console.log(this.nameProp),console.log(this.nameState)}componentDidUpdate(){console.log("componentDidUpdate()"),console.log(this.nameProp),console.log(this.nameState)}handleChangeProp(t){const e=t.target.value;console.log(e),this.nameProp=e}handleChangeState(t){const e=t.target.value;console.log(e),this.nameState=e}render(){return console.log("in render ftn"),t("div",null,t("h2",null,"Prop State Test"),t("p",null,"NameProp: ",this.nameProp),t("p",null,"NameState: ",this.nameState),t("span",null,"Note: State is internal. Will not be updated from external attribute settings.."),t("div",null,"Update PROP from within component: (will update. BUT WILL NOT RE-RENDER)",t("input",{type:"text",id:"nameProp",value:this.nameProp,onInput:t=>this.handleChangeProp(t)})),t("div",null,"Update STATE from within component: (will update AND RE-RENDER)",t("input",{type:"text",id:"nameState",value:this.nameState,onInput:t=>this.handleChangeState(t)})))}static get is(){return"prop-state-test"}static get encapsulation(){return"shadow"}static get properties(){return{nameProp:{type:String,attr:"name-prop"},nameState:{state:!0}}}}export{e as PropStateTest};